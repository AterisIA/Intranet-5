[Nota: Onde]
Dentro do menu "Perfil", crie um subitem chamado "Bater Ponto".

[Nota: Contexto sobre o prompt]
O prompt abaixo foi retirado de uma tela ja existente em outro projeto que preciso que seja recriada nessa. Nesse momento preciso que recrie com perfeição a tela, mas ignorando tudo sobre funcionalidades ou banco de dados, preciso apenas do visual nesse momento.

[Nota: Regras]
Pelo o prompt ser de outro projeto preciso que você imponha o visual e padrões do sistema.

[Nota: Prompt Mencionado}
Preciso criar uma tela de Bater Ponto (Registro de Ponto Eletrônico) que funcione de forma isolada, sem dependência de login ou autenticação. Esta tela implementa um fluxo completo de validação biométrica em múltiplas etapas usando React, TypeScript e Supabase.

Tecnologias Core: React 18.3.1, TypeScript, Vite, Tailwind CSS, Shadcn UI, Supabase 2.58.0, jsQR 1.4.0, face-api.js 0.22.2, date-fns 4.1.0, Lucide React 0.462.0.

Estrutura de Arquivos: A tela principal está em src/features/ponto/pages/BaterPonto.tsx e utiliza os seguintes componentes auxiliares: src/features/ponto/components/QRScanner.tsx (scanner de QR Code), src/features/ponto/components/FaceVerification.tsx (verificação facial), src/features/ponto/components/VideoRecorder.tsx (gravação de vídeo com prova de vida), src/features/ponto/components/RegistroPonto.tsx (interface de registro de ponto com cronômetros). Utiliza componentes Shadcn UI de src/components/ui (Card, Button, Alert, etc), cliente Supabase de src/integrations/supabase/client.ts e hook de toast de src/hooks/use-toast.ts.

Interfaces TypeScript em BaterPonto.tsx: Step é um tipo union com valores "scan" | "verify" | "liveness" | "registro" | "success" | "error" que controla o fluxo. PunchResult possui campos tipo (string), punched_at (string), nome opcional (string), confidence opcional (number), message opcional (string), face_user_id opcional (string), face_user opcional com objeto contendo id, nome, latitude e longitude opcionais, locationCheck opcional com objeto contendo isInLocation (boolean), distance (number) e address (string), e schedule_info opcional com objeto contendo status ('pontual' | 'atrasado' | 'fora_escala'), minutos_atraso (number) e horario_esperado (string ou null). VerificationData possui campos match (boolean), face_user_id opcional (string), nome opcional (string), similarity_score opcional (number), latitude e longitude opcionais (number) e message opcional (string).

Estado em BaterPonto.tsx: Gerencia step (Step, iniciando em "scan"), token (string vazia), result (PunchResult ou null), error (string vazia) e verificationData (VerificationData ou null) usando useState.

Fluxo de BaterPonto.tsx: Inicia na etapa "scan" exibindo QRScanner. Ao escanear QR Code válido, handleQRScanned armazena token, exibe toast de sucesso e muda para etapa "verify". Na etapa "verify", renderiza FaceVerification passando token. handleFaceVerified recebe resultado: se sucesso e match encontrado, armazena verificationData, exibe toast com confidence percentual, muda para etapa "liveness"; se falha, armazena mensagem de erro, exibe toast destrutivo e muda para etapa "error". Na etapa "liveness", renderiza VideoRecorder passando token, faceUserId e faceConfidence. handleLivenessComplete recebe resultado: se sucesso, exibe toasts para prova de vida e localização (se disponível), mescla dados com verificationData e muda para etapa "registro"; se falha, armazena erro, exibe toast destrutivo e muda para "error". Na etapa "registro", renderiza RegistroPonto com token, faceUserId, callback onSaidaComplete que reseta para "scan", requireValidationOnSaida verdadeiro e initialData com resultado do punch. handleReset reseta todos os estados para valores iniciais.

Renderização em BaterPonto.tsx: Container principal com max-w-2xl, título "Bater Ponto" e descrição. Se step não é "registro", exibe Card com título e descrição dinâmicos baseados na etapa atual. CardContent renderiza condicionalmente: QRScanner se step é "scan", FaceVerification se "verify" (com onCancel chamando handleReset), VideoRecorder se "liveness" (com onCancel), tela de sucesso se "success" (Alert verde com dados do resultado incluindo nome, tipo, horário, status de escala, atrasos, confidence e localização, botão para registrar novo ponto) ou tela de erro se "error" (Alert destrutivo com mensagem, botão para tentar novamente). Se step é "registro", renderiza Alert azul informando sucesso da verificação e RegistroPonto abaixo.

QRScanner.tsx: Componente que usa câmera traseira para escanear QR Codes. Interface QRScannerProps com callback onScanned. Estado gerencia error, scanning, loading e ref scannedRef para evitar múltiplos scans. useEffect inicializa câmera com getUserMedia (facingMode environment, 1280x720), configura videoRef, e loop de animação scanQR que desenha frames em canvas, usa jsQR para detectar código e chama onScanned. Tratamento de erros específico para NotAllowedError, NotFoundError e NotReadableError. Renderiza Alert se erro, Loader2 durante loading, video element com overlay animado quando scanning, canvas oculto e texto instrutivo.

FaceVerification.tsx: Componente de verificação facial com geolocalização. Interfaces GeoLocation (lat, lng, accuracy, timestamp, status), LocationCheckResult (isInLocation, distance, address). Props incluem token, onComplete e onCancel. Estado gerencia step (loading/ready/capturing/verifying), error, geoLocation, geoLoading, locationCheck. useEffect inicializa câmera frontal (facingMode user, 640x480) e outro useEffect vincula stream ao video quando step muda. captureGeolocation retorna Promise que solicita geolocalização com getCurrentPosition (enableHighAccuracy true, timeout 10s), atualiza estado e exibe toast. captureImage captura frame do video para canvas e retorna dataURL JPEG. handleCapture captura geo primeiro, depois imagem, muda para step "verifying", invoca edge function "verify-face" do Supabase com token, image, device_info. Trata respostas: se erro de rede exibe mensagem específica, se ok=false verifica código INVALID_TOKEN_SIGNATURE para expiração, se match=true chama onComplete com dados de verificação (face_user_id, nome, similarity_score, latitude, longitude), se match=false exibe mensagem pedindo cadastro facial. checkLocationByCoordinates e calculateDistance (fórmula Haversine) validam se usuário está dentro de 200m do local cadastrado. Renderiza Alert se erro, Loader2 durante loading, video element espelhado durante ready/capturing, Alerts informativos sobre localização e instruções, Alert com resultado de geolocalização se disponível, Alert com verificação de local se disponível, botões de Verificar Identidade (desabilitado durante capturing/geoLoading) e Cancelar.

VideoRecorder.tsx: Componente de gravação com detecção de prova de vida usando face-api.js. Interfaces GeoLocation, LocationCheckResult. Props incluem token, faceUserId, faceConfidence, onComplete e onCancel. Estado gerencia isRecording, isProcessing, countdown, error, loading, geoLocation, geoLoading, locationCheck, modelsLoaded, livenessCheck (hasMovement, headRotations, message). Refs para video, mediaRecorder, chunks, geo, detectionInterval, headPositions e livenessResult. useEffect carrega modelos do face-api.js (tinyFaceDetector e faceLandmark68Net) de CDN, definindo modelsLoaded. useEffect inicializa câmera frontal (facingMode user, 640x480). captureGeolocation idêntico ao FaceVerification. startRecording captura geo, inicia countdown de 3s que chama beginRecording. detectLivenessMovement retorna Promise que roda intervalo de 300ms por 3s detectando face com face-api, calculando yaw/pitch/roll aproximados dos landmarks, armazenando em headPositions. Após 3s calcula variância de movimento (threshold 0.001) e retorna resultado. calculateVariance calcula variância estatística. beginRecording limpa chunks e headPositions, cria MediaRecorder (video/webm vp8), inicia gravação, chama detectLivenessMovement se modelsLoaded, para após 3s. onstop aguarda liveness e chama uploadAndPunch. uploadAndPunch valida liveness (se modelsLoaded e sem movimento, falha com toast destrutivo), cria Blob, gera path YYYY-MM-DD/HHmmss-uuid.webm, faz upload para storage bucket "attendance-selfies", invoca edge function "punch" com token, selfie_path, face_user_id, face_confidence, device_info, geo. Se sucesso e há coordenadas, chama checkLocationByCoordinates e setLocationCheck. Chama onComplete com dados. Renderiza Alert se erro, Loader2 durante loading, video espelhado com overlay de countdown animado e indicador de gravação REC, Alerts informativos sobre localização e movimento (com nota se modelsLoaded=false), Alert com resultado de liveness se disponível, Alert com geo se disponível, Alert com locationCheck se disponível, botões de Iniciar Gravação (desabilitado durante recording/processing/countdown/loading/geoLoading) e Cancelar.

RegistroPonto.tsx: Componente de gerenciamento de ponto com cronômetros. Type EstadoPonto é 'ENTRADA' | 'PAUSA' | 'VOLTA_PAUSA' | 'SAIDA' | null. Interfaces RegistroPontoData (id, estado, timestamps opcionais, tempos em segundos, pausa_minutos_esperado), EscalaAtiva (idescala, dataescala, finalescala, pausa_minutos). Props incluem token, faceUserId, onSaidaComplete, requireValidationOnSaida, initialData. Estado gerencia estado (EstadoPonto), pausaIniciada (Date ou null), pausaMinimaMinutos (60), escalaAtiva, ultimoRegistro, loading, estados de validação (validandoSaida, stepValidacao, tokenSaida, verificationData). Hooks useTimer para trabalhoTimer (roda quando estado é ENTRADA ou VOLTA_PAUSA) e pausaTimer (roda quando PAUSA). useEffect inicial busca escalaAtiva e configura estado com initialData se fornecido, senão busca ultimoRegistro. useEffect atualiza timers quando ultimoRegistro carrega pela primeira vez. buscarEscalaAtiva busca em table escala com gte hoje. buscarUltimoRegistro busca em attendance_logs com gte hoje ordenado por punched_at desc, processa em RegistroPontoData. handleQRScanned, handleFaceVerified, handleLivenessComplete gerenciam fluxo de validação de saída. registrarPonto verifica se é SAIDA e requireValidationOnSaida para iniciar fluxo de validação, senão chama edge function punch com tipo solicitado, atualiza estado, gerencia pausaIniciada e timers, exibe toast e recarrega ultimoRegistro. podeVoltarDaPausa e tempoRestantePausa validam tempo mínimo de pausa. Calcula tempoLiquido subtraindo pausa de trabalho. Se validandoSaida, renderiza Card com fluxo QRScanner/FaceVerification/VideoRecorder. Senão renderiza Card principal com grid de 3 cronômetros (Trabalho, Pausa, Líquido) usando ícones Clock/Pause/RotateCcw e cores primary/warning/success, Alert se em pausa sem tempo mínimo, botões condicionais: Pausa (se ENTRADA ou VOLTA_PAUSA), Volta da Pausa (se PAUSA e podeVoltarDaPausa), Saída (se ENTRADA ou VOLTA_PAUSA), e informações da escalaAtiva (datas, pausa prevista).

Hook useTimer (src/hooks/useTimer.tsx): Custom hook que recebe running (boolean) e initialSeconds (number). Estado seconds inicia com initialSeconds. useEffect com intervalo que incrementa seconds quando running=true. Retorna objeto com seconds, formattedTime (formatado HH:MM:SS), setTime (função para atualizar seconds) e reset (zera seconds).

Edge Function verify-face (supabase/functions/verify-face/index.ts): Recebe POST com body contendo token (JWT), image (base64), device_info. Valida CORS. Decodifica token JWT manualmente verificando assinatura HMAC-SHA256 com secret do kiosk correspondente. Busca kiosk_id do payload, valida kiosk ativo. Converte image base64 para Uint8Array. Busca todos face_users, calcula similaridade euclidiana entre descriptors faciais. Se similaridade > 0.6 (threshold), registra log em face_recognition_logs e retorna ok=true, match=true com face_user_id, nome, similarity_score, latitude, longitude. Se não encontra match, retorna ok=true, match=false. Erros retornam ok=false com message e code apropriado.

Edge Function punch (supabase/functions/punch/index.ts): Recebe POST com token, selfie_path, face_user_id, face_confidence, device_info, geo (lat, lng, accuracy, timestamp, status), tipo opcional. Valida CORS. Decodifica e verifica token JWT. Busca kiosk, valida ativo. Se face_user_id fornecido, valida log recente em face_recognition_logs (últimos 2 minutos). Se selfie_path, verifica existência no storage. Previne replay attack verificando attendance_logs na mesma janela de tempo. Determina tipo de punch (ENTRADA/SAÍDA baseado em último registro se tipo não fornecido). Calcula tempos de trabalho e pausa diários. Processa geolocalização se geo.status ok. Busca escala do usuário (via telefone em attendance_logs cross join escala), calcula atrasos/adiantamentos, banco de horas. Insere em attendance_logs com todos os campos (kiosk_id, tipo, estado_ponto, punched_at, selfie_path, face_user_id, face_confidence, device_info, geo_*, data_registro, hora_registro, escala_id, horario_esperado, minutos_atraso, status_horario, tempo_trabalho_segundos, tempo_pausa_segundos, banco_horas_minutos, telefone). Retorna ok=true com dados completos do registro.

Tabela Supabase attendance_logs: Campos id (uuid, pk), kiosk_id (uuid nullable), tipo (text), estado_ponto (text nullable), punched_at (timestamptz), created_at (timestamptz), selfie_path (text nullable), face_user_id (uuid nullable), face_confidence (double precision nullable), device_info (jsonb nullable), geo_lat, geo_lng, geo_accuracy (double precision nullable), geo_timestamp (timestamptz nullable), geo_provider, geo_status (text nullable), data_registro (date nullable), hora_registro (time nullable), escala_id (integer nullable), horario_esperado, horario_previsto (timestamptz nullable), minutos_atraso (integer nullable, default 0), status_horario (text nullable, default 'pontual'), tempo_trabalho_segundos, tempo_pausa_segundos (integer nullable, default 0), banco_horas_minutos (integer nullable, default 0), telefone (numeric nullable), token_window, observacoes (text nullable). Trigger set_attendance_date_time preenche data_registro e hora_registro automaticamente. RLS: todos podem inserir e visualizar (políticas DEMO).

Tabela face_users: Campos id (uuid, pk), nome (text), matricula (text nullable), image_paths (text array), descriptor (double precision array nullable), facial_features (jsonb nullable), latitude, longitude (numeric nullable), endereco_profissional (text nullable), id_contato_terceirizacao (uuid nullable FK), description (text nullable), created_at (timestamptz). RLS: todos podem inserir e visualizar (DEMO).

Tabela face_recognition_logs: Campos id (uuid, pk), kiosk_id, face_user_id (uuid nullable), matched (boolean), similarity_score (double precision nullable), verification_image_path (text nullable), captured_at (timestamptz), note (text nullable). RLS: todos podem inserir e visualizar (DEMO).

Tabela kiosks: Campos id (uuid, pk), nome (text), local (text), segredo_base32 (text, usado para gerar tokens JWT), ativo (boolean, default true), created_at, updated_at (timestamptz). RLS: todos podem CRUD (DEMO).

Tabela escala: Campos idescala (integer, pk), nomepessoaescala (varchar), telefone (varchar nullable), dataescala (timestamp), finalescala (timestamp nullable), pausa_minutos (integer nullable), id_coordenador, id_plantao, id_contato_terceirizacao (uuid nullable FK), folgas_dias_semana, banco_horas_dias_semana (integer array), folgas_datas, banco_horas_datas (date array), domingo_mes (integer nullable). RLS: todos podem CRUD.

Cliente Supabase (src/integrations/supabase/client.ts): Exporta supabase criado com createClient usando SUPABASE_URL https://rxfrintflnnfgpwjlzmp.supabase.co e SUPABASE_PUBLISHABLE_KEY (anon key). Configurações auth: storage localStorage, persistSession true, autoRefreshToken true.

Estilização (src/index.css): Define CSS variables HSL para temas light/dark (--background, --foreground, --primary, --secondary, --muted, --accent, --destructive, --success, --warning, --border, --input, --ring). Font Inter. Classes Tailwind. Estilo .mirror { transform: scaleX(-1); } para espelhar vídeo.

Componentes Shadcn UI: Card (Card, CardHeader, CardTitle, CardDescription, CardContent), Button (variants default, destructive, outline, secondary, ghost, link; sizes default, sm, lg, icon), Alert (Alert, AlertDescription; variants default, destructive), ícones de lucide-react (Camera, Loader2, MapPin, CheckCircle2, XCircle, User, Clock, Pause, RotateCcw, StopCircle, Play). Toast via sonner (useToast hook, toast function).

Fluxo Completo de Bater Ponto: Usuário acessa /bater-ponto, escaneia QR Code do kiosque com câmera traseira, sistema verifica token JWT e valida kiosk, realiza verificação facial com câmera frontal capturando geolocalização, compara face com banco de dados, se match encontrado grava vídeo de 3s com detecção de movimento de cabeça (prova de vida), faz upload do vídeo para storage, chama edge function punch que valida todos os dados, busca escala, calcula atrasos/banco de horas, insere registro em attendance_logs, retorna resultado completo, exibe interface de RegistroPonto com cronômetros de trabalho/pausa/líquido e botões contextuais (Pausa, Volta da Pausa, Saída) baseados no estado atual. Saída pode requerer novo fluxo de validação completo se requireValidationOnSaida=true.

Recursos Especiais: Validação biométrica multi-fator (QR + Face + Liveness), detecção de prova de vida com face-api.js analisando movimento de cabeça, captura e validação de geolocalização HTML5, verificação de proximidade ao local cadastrado (200m), cálculo automático de atrasos e banco de horas baseado em escala, cronômetros em tempo real com persistência de tempos acumulados, prevenção de replay attacks, gestão de estados de ponto (ENTRADA, PAUSA, VOLTA_PAUSA, SAÍDA), tempo mínimo de pausa configurável, upload de vídeos para Supabase Storage, integração completa com edge functions, tratamento robusto de erros com mensagens amigáveis, suporte a modo sem geolocalização, validação de token JWT com HMAC-SHA256, RLS policies permissivas para demonstração.
